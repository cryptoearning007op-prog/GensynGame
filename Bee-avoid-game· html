<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Honeybee Pixel Avoid â€” 45s</title>
  <style>
    html,body{height:100%;margin:0;background:#000;display:flex;align-items:center;justify-content:center}
    canvas{background:#000;display:block;border:6px solid #111}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto}
    .ui{position:absolute;top:10px;left:10px;color:#fff;font-family:system-ui,Arial}
    .modal{background:rgba(0,0,0,0.9);color:#fff;padding:18px;border-radius:10px;text-align:center;max-width:520px}
    .btn{display:inline-block;margin:8px;padding:8px 14px;border-radius:8px;background:#ffda6b;color:#000;font-weight:700;cursor:pointer;border:none}
    .level-btn{margin:6px;padding:8px 12px;border-radius:8px;background:#fff;color:#000;font-weight:700;cursor:pointer;border:none}
    .small{font-size:13px;color:#ddd}
  </style>
</head>
<body>
  <canvas id="c" width="900" height="600"></canvas>
  <div class="overlay" id="overlay">
    <div class="modal" id="menu">
      <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-bottom:10px">
        <!-- man portrait is drawn on canvas so no external image required -->
        <canvas id="manCanvas" width="120" height="120" style="border-radius:8px;background:#fff"></canvas>
        <div style="text-align:left">
          <h2 style="margin:0 0 6px 0">Hey â€” ready to help the bee?</h2>
          <div class="small">Choose a difficulty, then Start. Tap/click/space to make the bee jump.</div>
        </div>
      </div>
      <div style="margin-top:6px">
        <div style="margin-bottom:8px">Pick a level (choose once before starting):</div>
        <div>
          <button class="level-btn" id="easyBtn">Easy</button>
          <button class="level-btn" id="hardBtn">Hard</button>
        </div>
        <div style="margin-top:12px">
          <button id="startBtn" class="btn">Start Game</button>
        </div>
        <div class="small" style="margin-top:8px">Goal: Survive 45 seconds without touching the pink logos (pixel rings). Score increases when you pass an obstacle.</div>
      </div>
    </div>
  </div>
  <div class="ui" id="ui">
    <div id="time">Time: 45</div>
    <div id="level" style="margin-top:6px">Level: -</div>
    <div id="score" style="margin-top:6px">Score: 0</div>
    <div id="status" style="margin-top:6px;color:#ffb6b6"></div>
  </div>

<script>
// Single-file game: no external images required. Obstacles are drawn pixel-by-pixel to match your pink logo style.
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// Menu elements
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const easyBtn = document.getElementById('easyBtn');
const hardBtn = document.getElementById('hardBtn');
const levelText = document.getElementById('level');
const timeText = document.getElementById('time');
const scoreText = document.getElementById('score');
const statusText = document.getElementById('status');

// Draw a simple "man" portrait onto manCanvas (so there's no 404)
(function drawMan(){
  const mc = document.getElementById('manCanvas');
  const mctx = mc.getContext('2d');
  mctx.fillStyle='#ff2d2d'; mctx.fillRect(0,0,mc.width,mc.height);
  mctx.fillStyle='#fff'; mctx.fillRect(8,8,104,104);
  mctx.fillStyle='#f5d0c8'; mctx.fillRect(22,18,80,60);
  mctx.fillStyle='#000'; mctx.fillRect(30,30,20,8); mctx.fillRect(70,30,20,8);
  mctx.fillRect(44,56,32,6);
})();

// Game params
let level = null; // 'easy'|'hard'
let started = false;
let timeLeft = 45;
let lastTime = null;
let obstacles = [];
let spawnTimer = 0;
let score = 0;
let gameOver = false;
let win = false;

const params = {
  easy: { gap: 200, speed: 140, spawnInterval: 1600 },
  hard: { gap: 120, speed: 260, spawnInterval: 1000 }
};
let curParams = params.easy;

// Bee sprite frames (simple procedural wings)
const bee = { x:140, y:H/2, vy:0, radius:20, gravity:0.9, jump:-15, wingPhase:0 };

// Pixel-style ring pattern (8x8 block ring) - we'll draw it tiled vertically for column obstacles
const pixelRing = [
  [0,1,1,1,1,1,1,0],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [0,1,1,1,1,1,1,0]
];

// Controls
function jump(){ if(!started) return; if(gameOver) return; bee.vy = bee.jump; audioJump(); }
canvas.addEventListener('mousedown', jump);
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); jump(); }, {passive:false});
window.addEventListener('keydown', (e)=>{ if(e.code==='Space') jump(); });

// Menu actions
easyBtn.onclick = ()=>{ level='easy'; curParams = params.easy; easyBtn.style.background='#ffeaa7'; hardBtn.style.background='#fff'; levelText.textContent='Level: Easy'; };
hardBtn.onclick = ()=>{ level='hard'; curParams = params.hard; hardBtn.style.background='#ffeaa7'; easyBtn.style.background='#fff'; levelText.textContent='Level: Hard'; };
startBtn.onclick = ()=>{ if(!level){ alert('Please choose Easy or Hard first.'); return; } startGame(); };

function startGame(){ started=true; overlay.style.display='none'; timeLeft=45; lastTime=performance.now(); obstacles=[]; spawnTimer=0; score=0; gameOver=false; win=false; bee.y=H/2; bee.vy=0; requestAnimationFrame(loop); }

// Create obstacle: vertical column made from tiled pixel rings, with a vertical gap
function spawnObstacle(){
  const gap = curParams.gap;
  const minY = 60; const maxY = H - 60 - gap;
  const gapY = Math.floor(Math.random()*(maxY-minY+1))+minY;
  obstacles.push({ x: W + 80, gapY, gap, tileSize: 28, passed:false });
}

// Collision detection between bee circle and obstacle column (tiled blocks)
function checkCollision(obs){
  const left = obs.x - obs.tileSize*4; // tile grid width = 8 -> rendered width tileSize*8 but ring narrower; use 8*tileSize
  const right = obs.x + obs.tileSize*4;
  if(bee.x + bee.radius < left || bee.x - bee.radius > right) return false;
  if( (bee.y - bee.radius) < obs.gapY || (bee.y + bee.radius) > (obs.gapY + obs.gap) ){
    return true; // touches solid area
  }
  return false;
}

// Draw pixel ring at x,y with tileSize scaling
function drawPixelRingAt(x,y,tileSize){
  const rows = pixelRing.length, cols = pixelRing[0].length;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(pixelRing[r][c]){
        ctx.fillStyle = '#f7cfcf';
        // draw with slight pixelated border effect
        ctx.fillRect(x + c*tileSize, y + r*tileSize, tileSize, tileSize);
      }
    }
  }
}

// Draw obstacle by tiling pixel rings vertically above and below gap
function drawObstacle(obs){
  const tile = obs.tileSize;
  const totalWidth = 8*tile;
  const left = obs.x - totalWidth/2;
  // top
  for(let y= - (8*tile); y < obs.gapY; y += 8*tile){
    drawPixelRingAt(left, y, tile);
  }
  // bottom
  for(let y=obs.gapY + obs.gap; y < H + 8*tile; y += 8*tile){
    drawPixelRingAt(left, y, tile);
  }
}

// Audio (WebAudio simple effects)
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioCtx ? new AudioCtx() : null;
function playBeep(freq, time, type='sine', gain=0.12){ if(!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type=type; o.frequency.value = freq; g.gain.value = gain; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + time); }
function audioJump(){ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); playBeep(800,0.08,'sine',0.06); }
function audioHit(){ playBeep(160,0.18,'sawtooth',0.15); }
function audioWin(){ playBeep(1200,0.08,'sine',0.08); setTimeout(()=>playBeep(900,0.08,'sine',0.06),90); }

// Main loop
function loop(ts){ if(!lastTime) lastTime = ts; const dt = Math.min(40, ts - lastTime); lastTime = ts; if(!started) return; if(gameOver){ draw(); displayEnd(); return; }
  // update time
  timeLeft -= dt/1000; if(timeLeft <= 0){ timeLeft = 0; win=true; gameOver=true; audioWin(); }
  // spawn
  spawnTimer += dt; if(spawnTimer > curParams.spawnInterval){ spawnTimer = 0; spawnObstacle(); }
  // move obstacles
  for(let i=obstacles.length-1;i>=0;i--){ const ob = obstacles[i]; ob.x -= curParams.speed * (dt/1000); if(!ob.passed && ob.x + 8*ob.tileSize/2 < bee.x){ ob.passed = true; score++; scoreText.textContent='Score: '+score; playBeep(600,0.06,'square',0.06); }
    if(ob.x < -200) obstacles.splice(i,1); }
  // physics
  bee.vy += bee.gravity; bee.y += bee.vy; bee.wingPhase += dt*0.02;
  if(bee.y + bee.radius > H){ bee.y = H - bee.radius; bee.vy = 0; gameOver=true; audioHit(); }
  if(bee.y - bee.radius < 0){ bee.y = bee.radius; bee.vy = 0; }
  // collisions
  for(const ob of obstacles){ if(checkCollision(ob)){ gameOver=true; audioHit(); break; } }
  draw(); if(!gameOver) requestAnimationFrame(loop);
}

function draw(){ ctx.clearRect(0,0,W,H); // bg
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  // finish line visual
  ctx.fillStyle='#0f0'; ctx.fillRect(W-12,0,6,H);
  // obstacles
  for(const ob of obstacles) drawObstacle(ob);
  // bee (sprite)
  drawBee();
  // UI
  timeText.textContent = 'Time: '+Math.ceil(timeLeft);
}

function drawBee(){ ctx.save(); ctx.translate(bee.x, bee.y);
  // body
  ctx.beginPath(); ctx.ellipse(0,0,bee.radius,bee.radius*0.8,0,0,Math.PI*2); ctx.fillStyle='#ffd24d'; ctx.fill();
  // stripes
  ctx.fillStyle='#222'; ctx.fillRect(-10,-8,20,6);
  // eye
  ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(6,-2,3,0,Math.PI*2); ctx.fill();
  // wings flap (two frames using wingPhase)
  const phase = Math.sin(bee.wingPhase);
  ctx.save(); ctx.rotate(-0.2+0.1*phase); ctx.beginPath(); ctx.ellipse(6,-18,12,8,0,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fill(); ctx.restore();
  ctx.restore(); }

function displayEnd(){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='28px system-ui'; if(win){ ctx.fillText('You survived 45s â€” You win! ðŸŽ‰', W/2, H/2 - 6); } else { ctx.fillText('Game Over â€” You hit a logo', W/2, H/2 - 6); }
  ctx.font='16px system-ui'; ctx.fillText('Tap to return to menu', W/2, H/2 + 30); }

// restart: tap after game over to go back to menu
canvas.addEventListener('mousedown', (e)=>{ if(gameOver){ overlay.style.display='flex'; started=false; } });
canvas.addEventListener('touchstart', (e)=>{ if(gameOver){ overlay.style.display='flex'; started=false; } }, {passive:false});

// responsive scaling
function resize(){ const maxW = Math.min(window.innerWidth - 20, 1100); const scale = Math.min(maxW / W, (window.innerHeight - 60) / H); canvas.style.width = Math.round(W*scale)+'px'; canvas.style.height = Math.round(H*scale)+'px'; }
window.addEventListener('resize', resize); resize();

// initial placeholder draw
(function initial(){ ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='22px system-ui'; ctx.textAlign='center'; ctx.fillText('Honeybee Pixel Avoid â€” Ready', W/2, H/2 - 6); ctx.font='14px system-ui'; ctx.fillText('Choose level and press Start. No external images required.', W/2, H/2 + 20); })();

</script>
</body>
</html>
