<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Honeybee â€” Final Improved</title>
<style>
  :root{--ui:#fff;--accent:#ffd54a;--muted:#cfcfcf}
  html,body{height:100%;margin:0;background:#07121a;font-family:system-ui,Arial,Helvetica,sans-serif;display:flex;align-items:center;justify-content:center}
  #wrap{position:relative;width:100%;max-width:1100px;padding:18px;box-sizing:border-box}
  canvas{display:block;width:100%;height:auto;border-radius:12px;box-shadow:0 18px 40px rgba(2,8,12,0.7);background:#07121a}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto}
  .modal{background:linear-gradient(180deg, rgba(0,0,0,0.86), rgba(4,8,6,0.9)); color:var(--ui); padding:16px;border-radius:12px; max-width:720px; width:92%}
  .row{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap}
  .btn{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;font-weight:700;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .file{background:#fff;border-radius:8px;padding:6px 8px}
  .ui{position:absolute;left:18px;top:18px;color:var(--ui)}
  .ui div{margin-bottom:8px;font-weight:700}
  .label{font-size:13px;color:var(--muted)}
  .level-btn{background:#fff;border-radius:8px;padding:8px 12px;cursor:pointer}
  .level-selected{outline:3px solid rgba(255,213,74,0.35)}
  #endControls{z-index:9999}
</style>
</head>
<body>
  <div id="wrap" aria-live="polite">
    <canvas id="game" width="980" height="620" aria-label="Honeybee game"></canvas>

    <div class="overlay" id="menuOverlay">
      <div class="modal" id="menu" role="dialog" aria-modal="true">
        <div style="display:flex;gap:12px;align-items:center">
          <canvas id="charCanvas" width="120" height="120" style="border-radius:8px;background:#fff"></canvas>
          <div style="flex:1">
            <h2 style="margin:0">Ready to help the bee?</h2>
            <div class="muted">Choose difficulty, optionally upload your exact logo & start-character, then Start. Tap/click/Space to jump.</div>
          </div>
        </div>

        <div style="margin-top:12px" class="row">
          <div style="min-width:220px">
            <div class="label">Pick a level:</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="easyBtn" class="level-btn">Easy (Member)</button>
              <button id="hardBtn" class="level-btn">Hard</button>
            </div>
            <div class="muted" style="margin-top:8px">Easy: much larger gaps, slower speed, longer spawns â€” member-friendly.</div>
          </div>

          <div style="min-width:260px">
            <div class="label">Upload EXACT logo (optional)</div>
            <input id="logoFile" class="file" type="file" accept="image/*">
            <div class="muted" style="margin-top:6px">This image will be used as the obstacle texture (pattern). Transparent logos work best.</div>
          </div>

          <div style="min-width:240px">
            <div class="label">Upload start-character (optional)</div>
            <input id="charFile" class="file" type="file" accept="image/*">
            <div class="muted" style="margin-top:6px">This image appears on the start screen and retry dialog.</div>
          </div>
        </div>

        <div style="margin-top:14px;display:flex;gap:12px;align-items:center;justify-content:center">
          <button id="startBtn" class="btn">Start Game</button>
          <button id="clearUploads" class="btn" style="background:#fff;color:#000">Clear Uploads</button>
        </div>
      </div>
    </div>

    <div class="ui" id="hud" aria-hidden="false">
      <div id="timeText">Time: 45</div>
      <div id="levelText" style="font-size:14px;margin-top:6px">Level: -</div>
      <div id="scoreText" style="font-size:14px;margin-top:6px">Score: 0</div>
    </div>
  </div>

<script>
/* Final improved single-file Honeybee game
   - clear bee visuals
   - createPattern for uploaded logo so obstacles look exactly like the logo
   - forgiving hitbox
   - retry dialog uses uploaded character
   - easier Easy mode
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// DOM
const menuOverlay = document.getElementById('menuOverlay');
const startBtn = document.getElementById('startBtn');
const easyBtn = document.getElementById('easyBtn');
const hardBtn = document.getElementById('hardBtn');
const logoFile = document.getElementById('logoFile');
const charFile = document.getElementById('charFile');
const clearUploads = document.getElementById('clearUploads');
const timeText = document.getElementById('timeText');
const levelText = document.getElementById('levelText');
const scoreText = document.getElementById('scoreText');
const charCanvas = document.getElementById('charCanvas');
const charCtx = charCanvas.getContext('2d');

// placeholder small character
(function placeholderChar(){
  const c = charCtx; c.clearRect(0,0,charCanvas.width,charCanvas.height);
  c.fillStyle='#7ccf9b'; c.fillRect(0,0,charCanvas.width,charCanvas.height);
  c.fillStyle='#fff'; c.fillRect(10,10,100,100);
  c.fillStyle='#f4c9a6'; c.fillRect(24,22,72,48);
  c.fillStyle='#222'; c.fillRect(36,36,10,6); c.fillRect(74,36,10,6);
})();

// Game state
let started=false, gameOver=false, win=false;
let level=null; // 'easy'|'hard'
let timeLeft=45;
let lastTime=null;
let score=0;
let obstacles=[];
let spawnTimer=0;

const params = {
  easy: { gap: 360, speed: 70, spawnInterval: 2400 }, // VERY forgiving
  hard: { gap: 120, speed: 320, spawnInterval: 900 }
};
let curParams = params.easy;

// Bee (clear & large)
const bee = { x: 180, y: H/2, vy:0, radius:30, gravity:0.9, jump:-16, wingPhase:0 };

// Logo pattern handling
let logoImg = null, logoReady=false, logoPattern=null;
logoFile.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = ()=> {
    const img = new Image();
    img.onload = ()=> {
      logoImg = img; logoReady = true;
      // create pattern sized to tile nicely: prefer original pixel appearance, so use no smoothing
      const tmp = document.createElement('canvas');
      const tctx = tmp.getContext('2d');
      tmp.width = img.width; tmp.height = img.height;
      // draw image into canvas preserving pixels
      tctx.imageSmoothingEnabled = false;
      tctx.drawImage(img,0,0);
      logoPattern = ctx.createPattern(tmp, 'repeat');
      showStatus('Logo loaded â€” obstacle pattern ready');
    };
    img.onerror = ()=> { logoImg=null; logoReady=false; logoPattern=null; showStatus('Logo failed to load'); };
    img.src = r.result;
  };
  r.readAsDataURL(f);
});

// Start-character handling
let startCharImg=null, charReady=false;
charFile.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0]; if(!f) return;
  const r = new FileReader();
  r.onload = ()=> {
    const img = new Image();
    img.onload = ()=> {
      startCharImg=img; charReady=true;
      // draw nicely into small canvas
      charCtx.clearRect(0,0,charCanvas.width,charCanvas.height);
      // fit cover
      const ar = img.width / img.height;
      let dw = charCanvas.width, dh = Math.round(dw / ar);
      if(dh < charCanvas.height){ dh = charCanvas.height; dw = Math.round(dh * ar); }
      const dx = (charCanvas.width-dw)/2, dy=(charCanvas.height-dh)/2;
      charCtx.imageSmoothingEnabled = true;
      charCtx.drawImage(img, dx, dy, dw, dh);
      showStatus('Character loaded');
    };
    img.onerror = ()=> { startCharImg=null; charReady=false; showStatus('Character failed'); };
    img.src = r.result;
  };
  r.readAsDataURL(f);
});

clearUploads.addEventListener('click', ()=>{
  logoImg=null; logoReady=false; logoPattern=null; logoFile.value='';
  startCharImg=null; charReady=false; charFile.value='';
  charCtx.clearRect(0,0,charCanvas.width,charCanvas.height);
  placeholderChar(); showStatus('Uploads cleared');
});

// Controls
function jump(){ if(!started) return; if(gameOver) return; bee.vy = bee.jump; audioJump(); }
canvas.addEventListener('mousedown', jump);
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); jump(); }, {passive:false});
window.addEventListener('keydown', (e)=>{ if(e.code==='Space') jump(); });

// Menu handlers
easyBtn.addEventListener('click', ()=>{ level='easy'; curParams=params.easy; easyBtn.classList.add('level-selected'); hardBtn.classList.remove('level-selected'); levelText.textContent='Level: Easy'; });
hardBtn.addEventListener('click', ()=>{ level='hard'; curParams=params.hard; hardBtn.classList.add('level-selected'); easyBtn.classList.remove('level-selected'); levelText.textContent='Level: Hard'; });
startBtn.addEventListener('click', ()=>{ if(!level){ alert('Choose Easy or Hard before starting.'); return;} startGame(); });

// Spawn obstacle using tileSize computed from logo or fallback
function spawnObstacle(){
  const gap = curParams.gap;
  const minY = 60, maxY = H - 60 - gap;
  const gapY = Math.floor(Math.random()*(maxY-minY+1))+minY;
  const tileSize = logoReady ? Math.max(28, Math.min(64, Math.round((logoImg.width + logoImg.height)/48))) : 28;
  obstacles.push({ x: W + 160, gapY, gap, tileSize, passed:false });
}

// Collision (forgiving: smaller hit radius)
function checkCollision(ob){
  const totalW = 8 * ob.tileSize;
  const left = ob.x - totalW/2, right = ob.x + totalW/2;
  const hitR = bee.radius * 0.72; // more forgiving
  if(bee.x + hitR < left || bee.x - hitR > right) return false;
  if( (bee.y - hitR) < ob.gapY || (bee.y + hitR) > (ob.gapY + ob.gap) ) return true;
  return false;
}

// Draw obstacles â€” use createPattern if logo uploaded (this preserves exact pixels)
function drawObstacle(ob){
  const tile = ob.tileSize;
  const totalW = 8*tile;
  const left = ob.x - totalW/2;
  // if logoPattern exists, draw tall rects filled with pattern
  if(logoPattern){
    ctx.save();
    ctx.translate(left, 0);
    ctx.fillStyle = logoPattern;
    // top column
    ctx.fillRect(0, 0, totalW, ob.gapY);
    // bottom column
    ctx.fillRect(0, ob.gapY + ob.gap, totalW, H - (ob.gapY + ob.gap));
    ctx.restore();
  } else {
    // fallback pixel rings tiled
    for(let y= - (8*tile); y < ob.gapY; y += 8*tile) drawPixelRingAt(left, y, tile);
    for(let y= ob.gapY + ob.gap; y < H + 8*tile; y += 8*tile) drawPixelRingAt(left, y, tile);
  }
}

const pixelRing = [
  [0,1,1,1,1,1,1,0],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [0,1,1,1,1,1,1,0]
];

function drawPixelRingAt(x,y,tile){
  for(let r=0;r<pixelRing.length;r++){
    for(let c=0;c<pixelRing[r].length;c++){
      if(pixelRing[r][c]){
        ctx.fillStyle = '#f7cfcf';
        ctx.fillRect(Math.round(x + c*tile), Math.round(y + r*tile), Math.ceil(tile), Math.ceil(tile));
      }
    }
  }
}

// Simple audio
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioCtx ? new AudioCtx() : null;
function playBeep(freq, dur, type='sine', g=0.08){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const gg = audioCtx.createGain();
  o.type=type; o.frequency.value=freq; gg.gain.value=g;
  o.connect(gg); gg.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}
function audioJump(){ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); playBeep(880,0.08,'sine',0.06); }
function audioHit(){ playBeep(160,0.22,'sawtooth',0.16); }
function audioWin(){ playBeep(1400,0.08,'sine',0.08); setTimeout(()=>playBeep(1000,0.08,'sine',0.06),120); }

// Start game
function startGame(){
  started=true; menuOverlay.style.display='none';
  timeLeft=45; lastTime=performance.now();
  score=0; scoreText.textContent='Score: 0';
  obstacles=[]; spawnTimer=0; gameOver=false; win=false;
  bee.y = H/2; bee.vy = 0;
  initClouds();
  requestAnimationFrame(loop);
}

// main loop
function loop(ts){
  if(!lastTime) lastTime = ts;
  const dt = Math.min(40, ts - lastTime);
  lastTime = ts;
  if(!started) return;
  if(gameOver){ draw(); showEndModal(); return; }

  // timer
  timeLeft -= dt/1000;
  if(timeLeft <= 0){ timeLeft = 0; win = true; gameOver = true; audioWin(); }

  // spawn obstacles
  spawnTimer += dt;
  if(spawnTimer > curParams.spawnInterval){ spawnTimer = 0; spawnObstacle(); }

  // move obstacles
  for(let i=obstacles.length-1;i>=0;i--){
    const ob = obstacles[i];
    ob.x -= curParams.speed * (dt/1000);
    if(!ob.passed && ob.x + 8*ob.tileSize/2 < bee.x){ ob.passed = true; score++; scoreText.textContent = 'Score: ' + score; playBeep(640,0.06,'square',0.06); }
    if(ob.x < -700) obstacles.splice(i,1);
  }

  // physics
  bee.vy += bee.gravity;
  bee.y += bee.vy;
  bee.wingPhase += dt*0.02;

  // floor/ceiling (slightly inset)
  if(bee.y + bee.radius > H - 12){ bee.y = H - 12 - bee.radius; bee.vy = 0; gameOver = true; audioHit(); }
  if(bee.y - bee.radius < 12){ bee.y = 12 + bee.radius; bee.vy = 0; }

  // collisions
  for(const ob of obstacles){
    if(checkCollision(ob)){ gameOver = true; audioHit(); break; }
  }

  draw();
  if(!gameOver) requestAnimationFrame(loop);
}

// Visuals: nature background with moving clouds
let cloudPositions = [];
function initClouds(){
  cloudPositions = [];
  const count = 7;
  for(let i=0;i<count;i++){
    cloudPositions.push({ x: Math.random()*W, y: 40 + Math.random()*80, speed: 0.2 + Math.random()*0.5, size: 60 + Math.random()*120 });
  }
}
initClouds();

function drawBackground(){
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#bfe9ff'); g.addColorStop(0.45,'#9fdfff'); g.addColorStop(1,'#79c3d9');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // sun
  const sunX = W - 120, sunY = 100;
  const sG = ctx.createRadialGradient(sunX,sunY,10,sunX,sunY,80);
  sG.addColorStop(0,'#fff8c8'); sG.addColorStop(1,'rgba(255,244,200,0)');
  ctx.fillStyle = sG; ctx.beginPath(); ctx.arc(sunX,sunY,80,0,Math.PI*2); ctx.fill();

  // hills layers
  drawHill('#2e8b57', 140, 0.25);
  drawHill('#36a86b', 90, 0.5);
  // foreground grass
  ctx.fillStyle = '#0f6b3a'; ctx.fillRect(0,H-44,W,44);
}

function drawHill(color, height, jitter){
  ctx.beginPath(); ctx.moveTo(0,H);
  const steps = 6;
  for(let i=0;i<=steps;i++){
    const px = (i/steps)*W;
    const py = H - height - Math.sin((i + Date.now()*0.0002)* (1 + jitter)) * (45 * jitter);
    ctx.quadraticCurveTo(px - W/steps*0.35, py + 10, px, py);
  }
  ctx.lineTo(W,H); ctx.closePath();
  ctx.fillStyle = color; ctx.fill();
}

function drawCloud(x,y,size){
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.beginPath();
  ctx.ellipse(x, y, size*0.6, size*0.34, 0, 0, Math.PI*2);
  ctx.ellipse(x + size*0.45, y + 6, size*0.5, size*0.32, 0, 0, Math.PI*2);
  ctx.ellipse(x - size*0.45, y + 4, size*0.48, size*0.30, 0, 0, Math.PI*2);
  ctx.fill();
}

// drawing main frame
function draw(){
  // background
  drawBackground();
  // clouds
  for(let c of cloudPositions){
    c.x += c.speed;
    if(c.x - 200 > W) c.x = -200;
    drawCloud(c.x, c.y, c.size);
  }
  // obstacles
  for(const ob of obstacles) drawObstacle(ob);
  // bee
  drawBee();
  // HUD via DOM
  timeText.textContent = 'Time: ' + Math.ceil(timeLeft);
  levelText.textContent = 'Level: ' + (level ? level[0].toUpperCase()+level.slice(1) : '-');
  scoreText.textContent = 'Score: ' + score;
}

// Bee drawing (clear, big)
function drawBee(){
  ctx.save();
  ctx.translate(Math.round(bee.x), Math.round(bee.y));
  // shadow
  ctx.beginPath(); ctx.ellipse(4, bee.radius*0.9 + 8, bee.radius*1.1, bee.radius*0.45, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.fill();
  // body
  ctx.beginPath(); ctx.ellipse(0,0,bee.radius*1.1,bee.radius*0.9,0,0,Math.PI*2); ctx.fillStyle = '#ffd54a'; ctx.fill();
  // stripes (clear)
  ctx.fillStyle = '#222';
  roundRect(ctx, -16, -14, 32, 12, 8, true, false);
  roundRect(ctx, -16, -2, 32, 12, 8, true, false);
  roundRect(ctx, -16, 10, 32, 12, 8, true, false);
  // face
  ctx.beginPath(); ctx.arc(9, -2, 8, 0, Math.PI*2); ctx.fillStyle = '#f6e3b8'; ctx.fill();
  // eye
  ctx.beginPath(); ctx.arc(11,-3,2.8,0,Math.PI*2); ctx.fillStyle='#000'; ctx.fill();
  // antennae
  ctx.strokeStyle='#221'; ctx.lineWidth=2.2; ctx.beginPath(); ctx.moveTo(3,-16); ctx.quadraticCurveTo(8,-30,14,-34); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(7,-16); ctx.quadraticCurveTo(16,-32,20,-30); ctx.stroke();
  // wings (flap)
  const phase = Math.sin(bee.wingPhase);
  ctx.save(); ctx.globalAlpha=0.95; ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.translate(-4,-6); ctx.rotate(-0.55 + 0.14*phase); ctx.beginPath(); ctx.ellipse(-8,-18,22,12,0,0,Math.PI*2); ctx.fill(); ctx.restore();
  ctx.save(); ctx.globalAlpha=0.86; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.translate(6,-6); ctx.rotate(0.45 - 0.12*phase); ctx.beginPath(); ctx.ellipse(12,-18,22,12,0,0,Math.PI*2); ctx.fill(); ctx.restore();
  // stinger
  ctx.beginPath(); ctx.fillStyle='#241f1f'; ctx.moveTo(-bee.radius*1.05,6); ctx.lineTo(-bee.radius*1.78,9); ctx.lineTo(-bee.radius*1.05,14); ctx.closePath(); ctx.fill();
  ctx.restore();
}

// rounded rect helper
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  if(fill) ctx.fill(); if(stroke) ctx.stroke();
}

/* End modal + retry */
function showEndModal(){
  // ensure only one modal
  if(document.getElementById('endControls')) return;
  // create overlay DOM for end choices
  const wrapper = document.createElement('div');
  wrapper.id='endControls';
  wrapper.style.position='absolute'; wrapper.style.left='0'; wrapper.style.top='0'; wrapper.style.width='100%'; wrapper.style.height='100%';
  wrapper.style.display='flex'; wrapper.style.alignItems='center'; wrapper.style.justifyContent='center'; wrapper.style.pointerEvents='auto';
  const box = document.createElement('div');
  box.style.background='rgba(0,0,0,0.6)'; box.style.padding='16px'; box.style.borderRadius='12px'; box.style.display='flex'; box.style.flexDirection='column'; box.style.alignItems='center'; box.style.gap='10px';
  const title = document.createElement('div');
  title.style.color='#fff'; title.style.fontSize='20px'; title.style.fontWeight='700';
  title.textContent = win ? 'You survived 45s â€” You win! ðŸŽ‰' : 'Game Over â€” You hit an obstacle';
  const scoreDiv = document.createElement('div'); scoreDiv.style.color='#fff'; scoreDiv.textContent = 'Score: ' + score;
  // character message
  const charMsg = document.createElement('div'); charMsg.style.color='#fff';
  if(charReady && startCharImg){
    // small img left, text right
    const wrap = document.createElement('div'); wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.gap='10px';
    const im = document.createElement('img'); im.src = startCharImg.src; im.style.width='56px'; im.style.height='56px'; im.style.objectFit='cover'; im.style.borderRadius='8px';
    const txt = document.createElement('div'); txt.style.color='#fff'; txt.textContent = win ? 'Nice! Try again and beat your score.' : 'Donâ€™t worry â€” try again!';
    wrap.appendChild(im); wrap.appendChild(txt);
    charMsg.appendChild(wrap);
  } else {
    charMsg.textContent = win ? 'Nice! Try again and beat your score.' : 'Donâ€™t worry â€” try again!';
  }
  const retryBtn = document.createElement('button'); retryBtn.className='btn'; retryBtn.textContent='Retry'; retryBtn.onclick = ()=>{ document.body.removeChild(wrapper); retry(); };
  const menuBtn = document.createElement('button'); menuBtn.className='btn'; menuBtn.style.background='#fff'; menuBtn.style.color='#000'; menuBtn.textContent='Return to Menu'; menuBtn.onclick = ()=>{ document.body.removeChild(wrapper); returnToMenu(); };
  box.appendChild(title); box.appendChild(scoreDiv); box.appendChild(charMsg); box.appendChild(retryBtn); box.appendChild(menuBtn);
  wrapper.appendChild(box); document.body.appendChild(wrapper);
}

function retry(){
  // continue with same level/uploads
  gameOver=false; win=false; timeLeft=45; lastTime=performance.now(); obstacles=[]; spawnTimer=0; score=0; scoreText.textContent='Score: 0';
  bee.y = H/2; bee.vy=0;
  requestAnimationFrame(loop);
}
function returnToMenu(){
  started=false; gameOver=false; win=false; mazeResetForMenu();
  menuOverlay.style.display='flex';
  timeText.textContent = 'Time: 45'; scoreText.textContent = 'Score: 0'; levelText.textContent = 'Level: -';
}
function mazeResetForMenu(){
  // small reset jobs (clouds)
  initClouds();
}

// show small HUD status
function showStatus(t){
  const div = document.createElement('div'); div.textContent = t;
  div.style.position='absolute'; div.style.right='26px'; div.style.top='26px';
  div.style.background='rgba(0,0,0,0.6)'; div.style.color='#fff'; div.style.padding='8px 10px'; div.style.borderRadius='8px'; div.style.zIndex='9999';
  document.body.appendChild(div);
  setTimeout(()=>{ div.style.transition='opacity 400ms'; div.style.opacity='0'; setTimeout(()=>div.remove(),420); }, 1800);
}

// init clouds
function initClouds(){ cloudPositions = []; for(let i=0;i<8;i++){ cloudPositions.push({ x: Math.random()*W, y: 40 + Math.random()*110, speed: 0.2 + Math.random()*0.45, size: 60 + Math.random()*140 }); } }
let cloudPositions = []; initClouds();

// responsive
function resize(){ const maxW = Math.min(window.innerWidth - 40, 1100); const scale = Math.min(maxW / W, (window.innerHeight - 60) / H); canvas.style.width = Math.round(W*scale) + 'px'; canvas.style.height = Math.round(H*scale) + 'px'; }
window.addEventListener('resize', resize); resize();

// initial canvas: draw menu scene with character
(function initialScreen(){
  drawBackground();
  drawBee();
  // message
  ctx.fillStyle='#fff'; ctx.font='20px system-ui'; ctx.textAlign='left';
  const msg = charReady ? 'I\'m ready â€” press Start!' : 'Press Start when ready!';
  ctx.fillText(msg, 60, 100);
  // loop while menu shown
  if(menuOverlay.style.display !== 'none') requestAnimationFrame(initialScreen);
})();

</script>
</body>
</html>
